syntax = "proto3";
package influxdata.iox.management.v1;

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

// `PartitionTemplate` is used to compute the partition key of each row that
// gets written. It can consist of the table name, a column name and its value,
// a formatted time, or a string column and regex captures of its value. For
// columns that do not appear in the input row, a blank value is output.
//
// The key is constructed in order of the template parts; thus ordering changes
// what partition key is generated.
message PartitionTemplate {
  message Part {
    message ColumnFormat {
      string column = 1;
      string format = 2;
    }

    oneof part {
      google.protobuf.Empty table = 1;
      string column = 2;
      string time = 3;
      ColumnFormat regex = 4;
      ColumnFormat strf_time = 5;
    }
  }

  repeated Part parts = 1;
}

message WalBufferConfig {
  enum Rollover {
    ROLLOVER_UNSPECIFIED = 0;

    // Drop the old segment even though it hasn't been persisted. This part of
    // the WAL will be lost on this server.
    ROLLOVER_DROP_OLD_SEGMENT = 1;

    // Drop the incoming write and fail silently. This favors making sure that
    // older WAL data will be backed up.
    ROLLOVER_DROP_INCOMING = 2;

    // Reject the incoming write and return an error. The client may retry the
    // request, which will succeed once the oldest segment has been
    // persisted to object storage.
    ROLLOVER_RETURN_ERROR = 3;
  }

  // The size the WAL buffer should be limited to. Once the buffer gets to
  // this size it will drop old segments to remain below this size, but
  // still try to hold as much in memory as possible while remaining
  // below this threshold
  uint64 buffer_size = 1;

  // WAL segments become read-only after crossing over this size. Which means
  // that segments will always be >= this size. When old segments are
  // dropped from of memory, at least this much space will be freed from
  // the buffer.
  uint64 segment_size = 2;

  // What should happen if a write comes in that would exceed the WAL buffer
  // size and the oldest segment that could be dropped hasn't yet been
  // persisted to object storage. If the oldest segment has been
  // persisted, then it will be dropped from the buffer so that new writes
  // can be accepted. This option is only for defining the behavior of what
  // happens if that segment hasn't been persisted. If set to return an
  // error, new writes will be rejected until the oldest segment has been
  // persisted so that it can be cleared from memory. Alternatively, this
  // can be set so that old segments are dropped even if they haven't been
  // persisted. This setting is also useful for cases where persistence
  // isn't being used and this is only for in-memory buffering.
  Rollover buffer_rollover = 3;

  // If set to true, buffer segments will be written to object storage.
  bool persist_segments = 4;

  // If set, segments will be rolled over after this period of time even
  // if they haven't hit the size threshold. This allows them to be written
  // out to object storage as they must be immutable first.
  google.protobuf.Duration close_segment_after = 5;
}

message MutableBufferConfig {
  // A chunk with more than this number of bytes should be transitioned from open -> closing
  uint64 open_chunk_size = 1;

  // A chunk that hasn't received a write for this number of milliseconds should be transitioned
  // from open -> closing
  uint32 open_chunk_linger_ms = 2;

  // A `closing` chunk that hasn't received a write for this number of milliseconds should be
  // transitioned from closing -> closed
  uint32 closing_chunk_linger_ms = 3;

  // A soft limit for the size the mutable buffer should be limited to. Once the buffer
  // exceeds this size IOx should start closing and transitioning chunks to the read buffer
  uint64 buffer_size_soft = 4;

  // A hard limit on the size of the mutable buffer. Once the buffer exceeds this size
  // it should start rejecting writes
  uint64 buffer_size_hard = 5;
}

message DatabaseRules {
  // The unencoded name of the database
  string name = 1;

  // Template that generates a partition key for each row inserted into the database
  PartitionTemplate partition_template = 2;

  // WAL configuration for this database
  WalBufferConfig wal_buffer_config = 6;

  // Mutable buffer configuration for this database
  MutableBufferConfig mutable_buffer_config = 7;
}
