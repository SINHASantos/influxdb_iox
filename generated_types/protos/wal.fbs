namespace wal;

// Every modification to a database is represented as an entry. These can be forwarded
// on to other IOx servers or can be wrapped with a sequence number for ordering in
// a WAL or subscribers.
//
// Take the example of sharding, where an IOx server is configured to split an
// incoming write into shards and send them onto others. The batch of line protocol
// written in a request will be split up so that each shard with data will have a
// single Entry that will be sent to it. Writes to multiple partitions can be
// represented with each having multiple lines. If the server that is doing the
// sharding is not generating partition keys, the key in partition write won't be
// present. It can be generated downstream. Although it's better to have the sharding
// layer generate the partition keys while it's at the job of parsing and validating
// the line protocol. This will save the downstream stateful layers from doing
// extra work.
//
// Even though this entry type has multiple fields (writes, deletes, others), they
// are mutually exclusive. That is an Entry will only ever have one of those fields.
// So you won't have an entry that has writes and deletes.
table Entry {
  // A collection of partition writes. A given partition will have at most one
  // write in this collection.
  writes: [PartitionWrite];
  // A collection of deletes. Each delete targets a single table, with each table
  // having no more than one delete. Deletes can span partitions because they
  // only have a predicate and do not target any specific partition.
  deletes: [Delete];
}

// A delete from a single table with a predicate. Deletes can span partitions since
// they're concerned with data that has already been written. Partitioning is a way
// to split up writes as they land.
table Delete {
  table_name: string;
  predicate: string;
}

// A write to a  partition. If the IOx server creating this PartitionWrite has
// no rules for generating partition keys, the key will be null, representing
// the empty string.
table PartitionWrite {
  key: string;
  table_batches: [TableWriteBatch];
}

// A collection of rows to write to a single table.
table TableWriteBatch {
  name: string;
  rows: [Row];
}

// A single row
table Row {
  values: [Value];
}

// A value for a specific column
table Value {
  column: string;
  value: ColumnValue;
}

union ColumnValue {
  TagValue,
  I64Value,
  U64Value,
  F64Value,
  BoolValue,
  StringValue
}

table TagValue {
  value: string;
}

table I64Value {
  value: int64;
}

table U64Value {
  value: uint64;
}

table F64Value {
  value: float64;
}

table BoolValue {
  value: bool;
}

table StringValue {
  value: string;
}

// The following definitions are for the WAL and for downstream subscribers to
// the WAL.

// Segment is a collection of RawEntries. It is the payload of a WAL
// segment file.
table Segment {
  // the segment number
  id: uint64;
  // the writer id of the server that persisted this segment
  writer_id: uint32;
  // the raw entry data along with their sequence numbers
  entries: [SequencedEntry];
}

// SequencedEntry are what get inserted into a WAL Buffer. These are
// what go out to subscribers of the WAL. The sequence numbers can
// be used to order the entries from a WAL server.
table SequencedEntry {
  sequence_number: uint64;
  writer_id: uint32;
  entry_data: [ubyte];
}
